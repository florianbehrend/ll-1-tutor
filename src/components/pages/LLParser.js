import React, {useContext, useState, useRef}  from 'react';
import Button from "../components/Button";
import { TextField, useScrollTrigger } from '@mui/material';
import { StepperContext } from "../context/StepperContext";
import { StoredContext } from "../context/StoredContext";
import Tree from 'react-d3-tree';
import { useCenteredTree } from '../utils/utils'; 
import '../layout/LLParser.css';
import { TreeStruc } from '../components/TreeStruc';

var inputErrorText = "Please enter your word!";

var correctTemp = {};

const timeOut = [];
const modifiedList = [];

let hasChanged = true;

function check(grammar){
  grammar.nonTerminals.slice(1).forEach((item, index) => {
    if(correctTemp[item] === undefined) {
      correctTemp[item] = [];
      for (let i = 0; i <= grammar.terminals.filter((sym) => sym !== 'e' && sym !== 'eps').length; i++) {
        correctTemp[item].push({correct: false, error: false, helpertext: "wrong elements", stepActive: false});  
      }
    }
  });
  console.log(correctTemp);
};

export default function LLParser ({children, className, containerClassName,  ...props}) {

  const {activeStep, setActiveStep} = useContext(StepperContext);
  const {grammar, setGrammar} = useContext(StoredContext);
  const {grammarObj, setGrammarObj} = useContext(StoredContext);
  const {parsingTable, setParsingTable} = useContext(StoredContext);
  const {nullableSet, setNullableSet} = useContext(StoredContext);

  const [solved, setSolved] = useState(false);
  const [correct, setCorrect] = useState(false);
  const [stepState, setStepState] = useState(0);
  const [stepStateRunning, setStepStateRunning] = useState(false);
  const [inputError, setInputError] = useState(false);
  const [treeData, setTreeData] = useState({});

  const [refresh, setRefresh] = useState(false);

  const inputRef = useRef();
  const parsingTableRef = useRef();

  const [dimensions, translate, containerRef] = useCenteredTree();

  const verticalTable = grammarObj.terminals.length >= grammarObj.nonTerminals.length;
  check(grammarObj);

  const handleNext = () => {    
    setActiveStep(0);
    correctTemp = {};
  };

  const handleBack = () => {
    setActiveStep((prevActiveStep) => prevActiveStep - 1);
    inputErrorText = "Please enter your word!";
    correctTemp = {};
  };

  const handleStep = () => {

  }

  const handleSolved = () => {
    //setSolved(true);
    const stack = ["S'"];
    const input = inputRef.current.value.split(" ").filter(sym => sym !== "");
    console.log(input);
    if(input.length === 0){
      setInputError(true);
      inputErrorText = "Please enter your word!";
      setRefresh(!refresh);
    }else {
      setInputError(false);
      runParser(grammarObj, stack, input, parsingTable);
    }

  }

  const runParser = (grammarObj, stack, input, parsingTable) => {
    const productionMap = new Map();
    const tree = new TreeStruc('1', "S'");
    var parentId = '1';
  
    grammarObj.productions.forEach(({lhs, rhs}) => {
      if (productionMap.get(lhs) === undefined) {
        productionMap.set(lhs, []);
      }
      productionMap.get(lhs).push(rhs);
    });
    
    console.log(productionMap);
  
    while(stack.length !== 0) {
      console.log("Length: " + stack.length);
  
      // initially it is S
      const A = stack.pop();
      

      /**
       * Add items to tree, when adding new Items on stack 
       * Stack will be [A, NodeId]
       * Wenn ich neue Items auf den Stack packe kenne ich die NodeId und kann diese als Children hinzufÃ¼gen.
       */
  
      //initially it is first symbol in string, it can be $ also
      const r = input[0] === undefined ? 'e' : input[0]; 
      console.log(A);
      console.log(r);
      if (grammarObj.terminals.includes(A) || A === '$') {
        console.log(stack);
          if(A===r || r==='e'){
              //pop A from stack;
              input.shift();
          }
          else{
            console.log("Error");
          }
       }
       else if (grammarObj.nonTerminals.includes(A)) {
        if(parsingTable[A][r] === undefined){
          if(r === 'e') {
            console.log(nullableSet.has(A));

          }else{
            console.log("Table undefined???");
            console.log(A);
            console.log(r);
            console.log(parsingTable);
            inputErrorText = "'" + r + "' cannot be generated by the grammar."
            setInputError(true);
            setRefresh(!refresh);
          }
        }else {
          if(parsingTable[A][r].size === 1) {
            //pop A from stack;
             console.log(parsingTable[A][r].values().next().value);
             console.log(productionMap.get(A));
             productionMap.get(A)[parsingTable[A][r].values().next().value].reduceRight((_, sym) => stack.push(sym),null);
             
             console.log(stack);

             if(A !== "S'"){
              const childId = parentId + tree.find(parentId).children.length;
              tree.insert(parentId, childId, A);
              console.log(tree);  
            }
             
            // B1 on top of stack at final of this step
            //push Bk,Bk-1......B1 on stack  
          } else if (parsingTable[A][r].size !== 1){
            const index = grammarObj.terminals.filter((sym) => sym !== 'e' && sym !== 'eps').indexOf(r);
            correctTemp[A][index].error = true;
            setRefresh(!refresh);
            parsingTableRef.current.scrollTop = (index+1)*34 - parsingTableRef.current.clientHeight/2
            console.log("Error2");         
         }
        }
           
       }
   } 

    console.log("This word can be build by this grammar");
    setCorrect(true);
  }


  const inputChange = () => {
    setCorrect(false);
  }

  const convention = 'Please enter your word that you want to parse. Each token must be separated by a space.';

  const orgChart = {
    name: 'CEO',
    children: [
      {
        name: 'Manager',
        children: [
          {
            name: 'Foreman',
            children: [
              {
                name: 'Worker',
              },
            ],
          },
          {
            name: 'Foreman',
            children: [
              {
                name: 'Worker',
              },
            ],
          },
        ],
      },
    ],
  };

  return (
    <div className='flex flex-col w-full h-full'>
        <div className='flex h-full'>
          <div className='w-1/3'>
            <div className='h-1/2 border-2 border-solid rounded-lg border-color p-2 text-left overflow-scroll' ref={parsingTableRef}>
            <div className='flex items-center justify-center'>
                <table className='border w-full '>
                {!verticalTable && <thead>
                    <tr class="border-b bg-zinc-800">
                        <th className='border-r max-w-4'>Nonterminal</th>
                        {grammarObj.terminals.filter((sym) => sym !== 'e' && sym !== 'eps').map((item, index) => (
                          <th className='border-r max-w-4'>{item}</th>
                        ))}
                        <th className='border-r max-w-4'>$</th>
                    </tr>
                </thead>}
                {verticalTable && <thead>
                    <tr class="border-b bg-zinc-800">
                        <th className='border-r max-w-4'>Terminals</th>
                        {grammarObj.nonTerminals.slice(1).map((item, index) => (
                          <th className='border-r max-w-4' id={index}>{item}</th>
                        ))}
                    </tr>
                </thead>}
                {!verticalTable && <tbody>
                    {grammarObj.nonTerminals.slice(1).map((item, index) => (
                        <tr class="border-b  ">
                            <td className='nonTerminal-table flex justify-center max-w-4'><p>{item}</p></td>
                            {grammarObj.terminals.filter((sym) => sym !== 'e' && sym !== 'eps').map((sym, ind) => (
                              <td className='border-r border-l max-w-4'><p className={correctTemp[item][ind].error ? "field-error" : ""}>{[...parsingTable[item][sym]].join(", ")}</p></td>
                            ))}
                            <td className='border-r border-l max-w-4'><p className={correctTemp[item][correctTemp[item].length - 1].error ? "field-error" : ""}>{[...parsingTable[item]['$']].join(", ")}</p></td>
                        </tr>
                    ))}
                </tbody>}
                {verticalTable && <tbody>
                    {grammarObj.terminals.filter((sym) => sym !== 'e' && sym !== 'eps').map((sym, index) => (
                        <tr class="border-b  ">
                            <td className='nonTerminal-table flex justify-center max-w-4'><p>{sym}</p></td>
                            {grammarObj.nonTerminals.slice(1).map((item, ind) => (
                             <td className='border-r border-l max-w-4'><p className={correctTemp[item][index].error ? "field-error" : ""}>{[...parsingTable[item][sym]].join(", ")}</p></td>
                            ))}
                        </tr>
                    ))}
                    <tr class="border-b  ">
                            <td className='nonTerminal-table flex justify-center max-w-4'><p>$</p></td>
                            {grammarObj.nonTerminals.slice(1).map((item, ind) => (
                             <td className='border-r border-l max-w-4'><p className={correctTemp[item][correctTemp[item].length - 1].error ? "field-error" : ""}>{[...parsingTable[item]['$']].join(", ")}</p></td>
                            ))}
                        </tr>
                </tbody>}
                </table>
                
            </div>


              </div>
              
            </div>
          <div className='flex flex-col w-2/3 items-center'>
            <p>{convention}</p>
            <TextField className='w-4/5 !m-2'
                  inputRef={inputRef}
                  sx={{
                    "& .MuiOutlinedInput-root": {
                      "& > fieldset": correct ? {borderColor: "#22c55e", borderWidth: 2} : {borderColor: "#2f2f2f", borderWidth: 2},
                    },
                    "& .MuiOutlinedInput-root:hover": { 
                      "& > fieldset": { borderColor: "#fde047", borderWidth: 3},
                    },
                  }}
                  variant="outlined"
                  error={inputError ? true : false}
                  helperText={inputError ? inputErrorText : ""}
                  onChange={inputChange}
                  />
            <div ref={containerRef} className='w-full h-full'>
              <Tree data={orgChart}
                dimensions={dimensions}
                translate={translate}
                zoom={1}
                orientation='vertical'
                collapsible={false} />
            </div>
            
          </div>
        </div>
        <div>
            <Button variant="contained" sx={{ mt: 3, ml: 1 }} onClick={handleBack}>
            Back
            </Button>
            <Button variant="contained" sx={{ mt: 3, ml: 1 }} onClick={handleStep} disabled={stepStateRunning}>
                {stepState!==2 ? (stepStateRunning ? 'Running...' : 'Next Step') : 'Restart'}
            </Button> 
            {solved
            ? <Button onClick={handleNext}>Finish</Button>
            : <Button onClick={handleSolved}>Solve</Button>     
            }
        </div>
    </div>
  )
}